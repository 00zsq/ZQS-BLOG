# 变量提升


- JavaScript允许在变量声明之前访问变量（仅适用于使用`var`声明的变量）。
- 在代码执行前，JavaScript会将**当前作用域内的所有`var`声明提升到作用域顶部**，但不会提升到外部作用域，并且**仅提升声明，不提升赋值**。

## 1. `var`的变量提升
在JavaScript中，使用`var`声明的变量会被提升到其所在作用域的顶部。这意味着变量可以在声明之前访问，但值为`undefined`。例如：

```javascript
console.log(a); // 输出 undefined
var a = 1;
```

在这段代码中，变量`a`的声明被提升到作用域顶部，但赋值操作仍然留在原地，因此输出`undefined`而不是报错。

## 2. `let`和`const`的引入及暂时性死区 (TDZ)
ES6引入了`let`和`const`关键字，它们的变量声明也会被提升，但在实际声明之前访问会抛出引用错误。这种现象被称为“暂时性死区”（Temporal Dead Zone, TDZ）。例如：

```javascript
console.log(b); // 抛出 ReferenceError
let b = 2;
```

在这里，由于`b`是用`let`声明的，在声明之前访问会导致引用错误。这与`var`不同，`var`允许在声明之前访问变量，但值为`undefined`。

## 3. 变量环境
变量环境是一个抽象概念，表示当前执行上下文中的所有变量和函数声明。每个执行上下文都有一个与之关联的变量环境：
- 全局执行上下文的变量环境是全局对象（如浏览器中的`window`或Node.js中的`global`）。
- 函数执行上下文的变量环境包含函数内部定义的变量和函数。

## 4. 词法环境
词法环境是JavaScript用于管理变量和函数声明的机制。它包含：
- 当前作用域内所有变量和函数的绑定信息。
- 对外部环境的引用，形成作用域链。

这种机制允许内部作用域访问外部作用域的变量，即使函数调用结束后，闭包仍然可以访问这些变量。

## 5. 调用栈与执行上下文
调用栈是JavaScript管理函数调用的机制。每次调用函数时，会创建一个新的执行上下文并推入调用栈顶部。函数执行完毕后，其执行上下文会从调用栈中弹出。例如：

```javascript
function a() {
  console.log("a");
  b();
}

function b() {
  console.log("b");
}

a(); // 输出 "a" 和 "b"
```

在这个例子中：
1. 调用`a`时，`a`的执行上下文被推入调用栈。
2. `a`调用`b`时，`b`的执行上下文被推入调用栈。
3. `b`执行完毕后，其执行上下文被移除，控制权返回给`a`。

## 6. 词法作用域与块级作用域
词法作用域基于代码书写的位置决定变量的可见性。函数创建时会记录其外部环境的引用，从而形成作用域链。块级作用域由`let`和`const`引入，限制变量的作用范围。例如：

```javascript
function foo() {
  var a = 1;
  let b = 2;
  {
    let b = 3; // 块级作用域内的b
    var c = 4; // 属于foo的作用域
    let d = 5; // 块级作用域内的d
    console.log(a); // 输出 1
    console.log(b); // 输出 3
  }
  console.log(b); // 输出 2
  console.log(c); // 输出 4
  console.log(d); // 抛出 ReferenceError: d is not defined
}
foo();
```

在这段代码中：
1. `a`和`c`被提升到`foo`的作用域顶部。
2. `b`和`d`被提升到各自的块级作用域，但在声明之前处于TDZ。
3. 块级作用域内的`b`覆盖了外部作用域的`b`。
4. `d`仅在块级作用域内可见，块外访问会抛出引用错误。

## 7. 原文来源掘金
[点击跳转](https://juejin.cn/post/7442226311169523746?searchId=2025041922411232CB93C6911CB881EF2C)
<GiscusComment />