# SSE 和 WebSocket 对比及应用场景

## 1. SSE: Server-Sent Events

### 使用场景
- **实时更新**：如股票行情、聊天应用中的实时消息推送、监控系统的实时数据等。
- **轻量级推送**：相比 WebSocket，SSE 实现更简单，仅需 HTTP 协议，且浏览器支持较好。

### 关键点
- **数据格式**：SSE 使用纯文本格式，通过事件流推送数据。服务器持续发送数据流，客户端通过事件监听接收消息。
- **单向通信**：SSE 是单向通信，服务器主动推送数据，客户端无法通过同一连接发送数据（需独立 HTTP 请求）。
- **自动重连**：浏览器原生支持自动重连，当连接中断时，客户端会自动尝试重新建立连接。

### 工作原理
1. **服务器端**：通过 HTTP 响应头 `Content-Type: text/event-stream` 表示 SSE 连接。
2. **客户端**：使用 JavaScript 的 `EventSource` API 接收服务端推送的事件。

### 主要事件
- `onmessage`：接收服务端发送的消息。
- `onopen`：连接建立时触发。
- `onerror`：出现错误或连接中断时触发。

### SSE 与 WebSocket 的区别
| 特性           | SSE                          | WebSocket                     |
|----------------|------------------------------|--------------------------------|
| **通信方向**   | 单向（服务端到客户端）       | 双向通信                      |
| **连接复杂度** | 使用 HTTP 协议，较简单       | 独立协议，复杂性稍高          |
| **浏览器支持** | 大多数现代浏览器支持较好     | 广泛支持，但需额外处理兼容性  |
| **自动重连**   | 内置自动重连机制             | 需手动处理重连逻辑            |

SSE 是适合实时数据推送的轻量级解决方案。

---

## fetchEventSource

`fetchEventSource` 是一个用于处理 SSE 的 JavaScript 函数，提供更灵活的 SSE 处理方案。

### 主要功能
- **接收流数据**：与 `EventSource` 类似，用于处理服务器推送的文本流数据。
- **自动重连**：支持自动重连机制，连接断开时会尝试重新连接。
- **自定义控制**：相比原生 `EventSource`，支持更灵活的请求头、重连行为等。

### 优势
- **灵活性**：基于 `fetch`，允许自定义请求头和重连逻辑。
- **更好控制**：通过事件钩子（如 `onopen`, `onmessage`, `onclose`），灵活控制数据接收过程。
- **错误处理**：支持更详细的错误处理，区分客户端和服务器错误。

### 适用场景
- **长连接数据流**：如实时股票数据、消息推送、进度条更新等。
- **更好控制流**：需要自定义请求头、重连策略等场景。

`fetchEventSource` 是原生 SSE 的增强实现，适合复杂前端应用中接收服务端推送数据的场景。

---

## 2. WebSocket

WebSocket 是一种支持客户端与服务器之间全双工通信的协议，适用于实时数据更新的场景。

### 特点
- **全双工通信**：客户端和服务器可同时发送和接收消息。
- **持久化连接**：连接建立后保持长连接，无需重复建立。
- **低开销**：头部信息少，频繁数据交互时带宽占用更少。
- **实时性强**：低延迟，适合快速更新数据的场景。

### 工作原理
1. **建立连接（握手）**：
  - 客户端发送 `Upgrade` 请求，服务器返回 `101 Switching Protocols` 响应，完成协议升级。
2. **数据传输**：
  - 使用 WebSocket 帧格式传输数据，支持文本帧和二进制帧。
3. **关闭连接**：
  - 任意一方发送关闭帧，另一方响应后断开连接。

### WebSocket 与 HTTP 的区别
| 特性           | WebSocket                     | HTTP                          |
|----------------|-------------------------------|-------------------------------|
| **连接模型**   | 全双工连接，持续连接          | 半双工，请求-响应模式         |
| **实时性**     | 适合实时、低延迟通信场景      | 需轮询或长连接模拟实时性      |
| **数据传输**   | 支持文本和二进制数据          | 主要传输文本（如 JSON）       |
| **头部开销**   | 一次握手，后续开销小          | 每次请求/响应都带完整头部信息 |
| **长连接**     | 是，长时间保持连接            | 默认不支持，需 HTTP/2 或长轮询|

### 应用场景
- **在线聊天/消息传递**：支持实时消息传递，延迟低。
- **实时通知**：如股票行情、体育比分等实时推送。
- **多人协作/游戏**：保持客户端同步，支持低延迟双向通信。
- **物联网（IoT）**：设备与服务器间实时数据传输。
- **实时数据流**：如视频流或音频流的低延迟传输。

### 局限性
- **浏览器兼容性**：旧版浏览器（如 IE 10 以下）可能不支持。
- **防火墙和代理**：部分防火墙和代理可能不支持 WebSocket。
- **复杂性**：需额外处理状态管理、断线重连和错误处理。

WebSocket 是适合实时、双向通信的强大工具，但需权衡复杂性和应用场景。

## 3. 使用感受
个人使用下来SSE挺难用的

## 4. 掘金文章
[点击跳转](https://juejin.cn/post/7415914052457398284?searchId=20250420222125E439F9C78453270ED1BB)
<GiscusComment />