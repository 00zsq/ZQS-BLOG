import{_ as a,B as l,c as i,o as t,ai as r,G as c}from"./chunks/framework.jrH_H5Hh.js";const T=JSON.parse('{"title":"页面从 URL 输入到渲染完成的全过程","description":"","frontmatter":{},"headers":[],"relativePath":"my-blog/browser/URL.md","filePath":"my-blog/browser/URL.md"}'),d={name:"my-blog/browser/URL.md"};function n(s,e,h,p,u,_){const o=l("GiscusComment");return t(),i("div",null,[e[0]||(e[0]=r('<h1 id="页面从-url-输入到渲染完成的全过程" tabindex="-1">页面从 URL 输入到渲染完成的全过程 <a class="header-anchor" href="#页面从-url-输入到渲染完成的全过程" aria-label="Permalink to &quot;页面从 URL 输入到渲染完成的全过程&quot;">​</a></h1><p>以下是一个页面从输入 URL 到渲染完成的关键步骤：</p><h2 id="_1-url-解析" tabindex="-1">1. URL 解析 <a class="header-anchor" href="#_1-url-解析" aria-label="Permalink to &quot;1. URL 解析&quot;">​</a></h2><p>浏览器解析 URL，提取以下信息：</p><ul><li>协议（如 <code>http</code>/<code>https</code>）</li><li>主机名（如 <code>www.example.com</code>）</li><li>端口号（默认 <code>80</code>/<code>443</code>）</li><li>路径和查询参数</li></ul><h2 id="_2-dns-解析" tabindex="-1">2. DNS 解析 <a class="header-anchor" href="#_2-dns-解析" aria-label="Permalink to &quot;2. DNS 解析&quot;">​</a></h2><p>通过 DNS 查询将域名转换为 IP 地址，查询顺序如下：</p><ol><li>浏览器缓存</li><li>操作系统缓存</li><li>路由器缓存</li><li>ISP DNS 缓存</li><li>递归查询根 DNS 服务器<br> 例如：<code>www.baidu.com</code> 解析为 <code>220.181.38.150</code></li></ol><h2 id="_3-建立-tcp-连接" tabindex="-1">3. 建立 TCP 连接 <a class="header-anchor" href="#_3-建立-tcp-连接" aria-label="Permalink to &quot;3. 建立 TCP 连接&quot;">​</a></h2><p>通过三次握手建立 TCP 连接：</p><ol><li>客户端发送 <code>SYN=1, Seq=x</code></li><li>服务端返回 <code>SYN=1, ACK=1, Seq=y, Ack=x+1</code></li><li>客户端发送 <code>ACK=1, Seq=x+1, Ack=y+1</code><br> 若为 HTTPS，还需进行 TLS 握手协商加密。</li></ol><h2 id="_4-发送-http-请求" tabindex="-1">4. 发送 HTTP 请求 <a class="header-anchor" href="#_4-发送-http-请求" aria-label="Permalink to &quot;4. 发送 HTTP 请求&quot;">​</a></h2><p>浏览器发送 HTTP 请求，包括：</p><ul><li>请求行（如 <code>GET /index.html HTTP/1.1</code>）</li><li>请求头（如 <code>Host</code>、<code>User-Agent</code>）</li><li>请求体（如 POST 数据）</li></ul><h2 id="_5-服务器处理响应" tabindex="-1">5. 服务器处理响应 <a class="header-anchor" href="#_5-服务器处理响应" aria-label="Permalink to &quot;5. 服务器处理响应&quot;">​</a></h2><p>服务器处理请求后返回：</p><ul><li>状态行（如 <code>HTTP/1.1 200 OK</code>）</li><li>响应头（如 <code>Content-Type</code>）</li><li>响应体（HTML 内容）</li></ul><h2 id="_6-浏览器渲染流程" tabindex="-1">6. 浏览器渲染流程 <a class="header-anchor" href="#_6-浏览器渲染流程" aria-label="Permalink to &quot;6. 浏览器渲染流程&quot;">​</a></h2><ol><li><strong>构建 DOM 树</strong>：解析 HTML 生成文档对象模型。</li><li><strong>构建 CSSOM</strong>：解析 CSS 样式表。</li><li><strong>生成渲染树</strong>：合并 DOM 和 CSSOM，排除不可见元素。</li><li><strong>布局（Layout）</strong>：计算元素的精确位置和大小。</li><li><strong>绘制（Painting）</strong>：将渲染树转换为屏幕像素。</li><li><strong>合成（Compositing）</strong>：分层绘制以优化性能。</li></ol><h2 id="_7-加载子资源" tabindex="-1">7. 加载子资源 <a class="header-anchor" href="#_7-加载子资源" aria-label="Permalink to &quot;7. 加载子资源&quot;">​</a></h2><p>解析 HTML 时，遇到 <code>&lt;img&gt;</code>、<code>&lt;script&gt;</code> 等标签会发起新的 HTTP 请求加载资源，可能触发重排（Reflow）和重绘（Repaint）。</p><h2 id="_8-javascript-执行" tabindex="-1">8. JavaScript 执行 <a class="header-anchor" href="#_8-javascript-执行" aria-label="Permalink to &quot;8. JavaScript 执行&quot;">​</a></h2><ul><li>同步脚本会阻塞 DOM 解析。</li><li>异步脚本（如 <code>async</code>/<code>defer</code>）按特定时机执行。</li></ul><p>整个过程涉及浏览器多线程协作（如 GUI 渲染线程、JS 引擎线程、HTTP 请求线程等）。现代浏览器还通过预加载扫描器（Preload Scanner）优化资源加载。</p>',24)),c(o)])}const P=a(d,[["render",n]]);export{T as __pageData,P as default};
