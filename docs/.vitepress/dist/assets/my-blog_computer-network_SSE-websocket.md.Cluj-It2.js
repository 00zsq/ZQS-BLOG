import{_ as o,B as r,c as a,o as l,ai as n,G as s}from"./chunks/framework.jrH_H5Hh.js";const k=JSON.parse('{"title":"SSE 和 WebSocket 对比及应用场景","description":"","frontmatter":{},"headers":[],"relativePath":"my-blog/computer-network/SSE-websocket.md","filePath":"my-blog/computer-network/SSE-websocket.md"}'),i={name:"my-blog/computer-network/SSE-websocket.md"};function d(c,t,h,g,u,b){const e=r("GiscusComment");return l(),a("div",null,[t[0]||(t[0]=n('<h1 id="sse-和-websocket-对比及应用场景" tabindex="-1">SSE 和 WebSocket 对比及应用场景 <a class="header-anchor" href="#sse-和-websocket-对比及应用场景" aria-label="Permalink to &quot;SSE 和 WebSocket 对比及应用场景&quot;">​</a></h1><h2 id="_1-sse-server-sent-events" tabindex="-1">1. SSE: Server-Sent Events <a class="header-anchor" href="#_1-sse-server-sent-events" aria-label="Permalink to &quot;1. SSE: Server-Sent Events&quot;">​</a></h2><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><ul><li><strong>实时更新</strong>：如股票行情、聊天应用中的实时消息推送、监控系统的实时数据等。</li><li><strong>轻量级推送</strong>：相比 WebSocket，SSE 实现更简单，仅需 HTTP 协议，且浏览器支持较好。</li></ul><h3 id="关键点" tabindex="-1">关键点 <a class="header-anchor" href="#关键点" aria-label="Permalink to &quot;关键点&quot;">​</a></h3><ul><li><strong>数据格式</strong>：SSE 使用纯文本格式，通过事件流推送数据。服务器持续发送数据流，客户端通过事件监听接收消息。</li><li><strong>单向通信</strong>：SSE 是单向通信，服务器主动推送数据，客户端无法通过同一连接发送数据（需独立 HTTP 请求）。</li><li><strong>自动重连</strong>：浏览器原生支持自动重连，当连接中断时，客户端会自动尝试重新建立连接。</li></ul><h3 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><ol><li><strong>服务器端</strong>：通过 HTTP 响应头 <code>Content-Type: text/event-stream</code> 表示 SSE 连接。</li><li><strong>客户端</strong>：使用 JavaScript 的 <code>EventSource</code> API 接收服务端推送的事件。</li></ol><h3 id="主要事件" tabindex="-1">主要事件 <a class="header-anchor" href="#主要事件" aria-label="Permalink to &quot;主要事件&quot;">​</a></h3><ul><li><code>onmessage</code>：接收服务端发送的消息。</li><li><code>onopen</code>：连接建立时触发。</li><li><code>onerror</code>：出现错误或连接中断时触发。</li></ul><h3 id="sse-与-websocket-的区别" tabindex="-1">SSE 与 WebSocket 的区别 <a class="header-anchor" href="#sse-与-websocket-的区别" aria-label="Permalink to &quot;SSE 与 WebSocket 的区别&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>SSE</th><th>WebSocket</th></tr></thead><tbody><tr><td><strong>通信方向</strong></td><td>单向（服务端到客户端）</td><td>双向通信</td></tr><tr><td><strong>连接复杂度</strong></td><td>使用 HTTP 协议，较简单</td><td>独立协议，复杂性稍高</td></tr><tr><td><strong>浏览器支持</strong></td><td>大多数现代浏览器支持较好</td><td>广泛支持，但需额外处理兼容性</td></tr><tr><td><strong>自动重连</strong></td><td>内置自动重连机制</td><td>需手动处理重连逻辑</td></tr></tbody></table><p>SSE 是适合实时数据推送的轻量级解决方案。</p><hr><h2 id="fetcheventsource" tabindex="-1">fetchEventSource <a class="header-anchor" href="#fetcheventsource" aria-label="Permalink to &quot;fetchEventSource&quot;">​</a></h2><p><code>fetchEventSource</code> 是一个用于处理 SSE 的 JavaScript 函数，提供更灵活的 SSE 处理方案。</p><h3 id="主要功能" tabindex="-1">主要功能 <a class="header-anchor" href="#主要功能" aria-label="Permalink to &quot;主要功能&quot;">​</a></h3><ul><li><strong>接收流数据</strong>：与 <code>EventSource</code> 类似，用于处理服务器推送的文本流数据。</li><li><strong>自动重连</strong>：支持自动重连机制，连接断开时会尝试重新连接。</li><li><strong>自定义控制</strong>：相比原生 <code>EventSource</code>，支持更灵活的请求头、重连行为等。</li></ul><h3 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h3><ul><li><strong>灵活性</strong>：基于 <code>fetch</code>，允许自定义请求头和重连逻辑。</li><li><strong>更好控制</strong>：通过事件钩子（如 <code>onopen</code>, <code>onmessage</code>, <code>onclose</code>），灵活控制数据接收过程。</li><li><strong>错误处理</strong>：支持更详细的错误处理，区分客户端和服务器错误。</li></ul><h3 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;适用场景&quot;">​</a></h3><ul><li><strong>长连接数据流</strong>：如实时股票数据、消息推送、进度条更新等。</li><li><strong>更好控制流</strong>：需要自定义请求头、重连策略等场景。</li></ul><p><code>fetchEventSource</code> 是原生 SSE 的增强实现，适合复杂前端应用中接收服务端推送数据的场景。</p><hr><h2 id="_2-websocket" tabindex="-1">2. WebSocket <a class="header-anchor" href="#_2-websocket" aria-label="Permalink to &quot;2. WebSocket&quot;">​</a></h2><p>WebSocket 是一种支持客户端与服务器之间全双工通信的协议，适用于实时数据更新的场景。</p><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ul><li><strong>全双工通信</strong>：客户端和服务器可同时发送和接收消息。</li><li><strong>持久化连接</strong>：连接建立后保持长连接，无需重复建立。</li><li><strong>低开销</strong>：头部信息少，频繁数据交互时带宽占用更少。</li><li><strong>实时性强</strong>：低延迟，适合快速更新数据的场景。</li></ul><h3 id="工作原理-1" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理-1" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><ol><li><strong>建立连接（握手）</strong>：</li></ol><ul><li>客户端发送 <code>Upgrade</code> 请求，服务器返回 <code>101 Switching Protocols</code> 响应，完成协议升级。</li></ul><ol start="2"><li><strong>数据传输</strong>：</li></ol><ul><li>使用 WebSocket 帧格式传输数据，支持文本帧和二进制帧。</li></ul><ol start="3"><li><strong>关闭连接</strong>：</li></ol><ul><li>任意一方发送关闭帧，另一方响应后断开连接。</li></ul><h3 id="websocket-与-http-的区别" tabindex="-1">WebSocket 与 HTTP 的区别 <a class="header-anchor" href="#websocket-与-http-的区别" aria-label="Permalink to &quot;WebSocket 与 HTTP 的区别&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>WebSocket</th><th>HTTP</th></tr></thead><tbody><tr><td><strong>连接模型</strong></td><td>全双工连接，持续连接</td><td>半双工，请求-响应模式</td></tr><tr><td><strong>实时性</strong></td><td>适合实时、低延迟通信场景</td><td>需轮询或长连接模拟实时性</td></tr><tr><td><strong>数据传输</strong></td><td>支持文本和二进制数据</td><td>主要传输文本（如 JSON）</td></tr><tr><td><strong>头部开销</strong></td><td>一次握手，后续开销小</td><td>每次请求/响应都带完整头部信息</td></tr><tr><td><strong>长连接</strong></td><td>是，长时间保持连接</td><td>默认不支持，需 HTTP/2 或长轮询</td></tr></tbody></table><h3 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h3><ul><li><strong>在线聊天/消息传递</strong>：支持实时消息传递，延迟低。</li><li><strong>实时通知</strong>：如股票行情、体育比分等实时推送。</li><li><strong>多人协作/游戏</strong>：保持客户端同步，支持低延迟双向通信。</li><li><strong>物联网（IoT）</strong>：设备与服务器间实时数据传输。</li><li><strong>实时数据流</strong>：如视频流或音频流的低延迟传输。</li></ul><h3 id="局限性" tabindex="-1">局限性 <a class="header-anchor" href="#局限性" aria-label="Permalink to &quot;局限性&quot;">​</a></h3><ul><li><strong>浏览器兼容性</strong>：旧版浏览器（如 IE 10 以下）可能不支持。</li><li><strong>防火墙和代理</strong>：部分防火墙和代理可能不支持 WebSocket。</li><li><strong>复杂性</strong>：需额外处理状态管理、断线重连和错误处理。</li></ul><p>WebSocket 是适合实时、双向通信的强大工具，但需权衡复杂性和应用场景。</p><h2 id="_3-使用感受" tabindex="-1">3. 使用感受 <a class="header-anchor" href="#_3-使用感受" aria-label="Permalink to &quot;3. 使用感受&quot;">​</a></h2><p>个人使用下来SSE挺难用的</p><h2 id="_4-掘金文章" tabindex="-1">4. 掘金文章 <a class="header-anchor" href="#_4-掘金文章" aria-label="Permalink to &quot;4. 掘金文章&quot;">​</a></h2><p><a href="https://juejin.cn/post/7415914052457398284?searchId=20250420222125E439F9C78453270ED1BB" target="_blank" rel="noreferrer">点击跳转</a></p>',46)),s(e)])}const m=o(i,[["render",d]]);export{k as __pageData,m as default};
