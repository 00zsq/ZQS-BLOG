import{_ as a,B as n,c as l,o as e,ai as t,G as h}from"./chunks/framework.jrH_H5Hh.js";const y=JSON.parse('{"title":"变量提升","description":"","frontmatter":{},"headers":[],"relativePath":"my-blog/JS/var-lifting.md","filePath":"my-blog/JS/var-lifting.md"}'),p={name:"my-blog/JS/var-lifting.md"};function k(d,s,o,r,c,E){const i=n("GiscusComment");return e(),l("div",null,[s[0]||(s[0]=t(`<h1 id="变量提升" tabindex="-1">变量提升 <a class="header-anchor" href="#变量提升" aria-label="Permalink to &quot;变量提升&quot;">​</a></h1><ul><li>JavaScript允许在变量声明之前访问变量（仅适用于使用<code>var</code>声明的变量）。</li><li>在代码执行前，JavaScript会将<strong>当前作用域内的所有<code>var</code>声明提升到作用域顶部</strong>，但不会提升到外部作用域，并且<strong>仅提升声明，不提升赋值</strong>。</li></ul><h2 id="_1-var的变量提升" tabindex="-1">1. <code>var</code>的变量提升 <a class="header-anchor" href="#_1-var的变量提升" aria-label="Permalink to &quot;1. \`var\`的变量提升&quot;">​</a></h2><p>在JavaScript中，使用<code>var</code>声明的变量会被提升到其所在作用域的顶部。这意味着变量可以在声明之前访问，但值为<code>undefined</code>。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 undefined</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>在这段代码中，变量<code>a</code>的声明被提升到作用域顶部，但赋值操作仍然留在原地，因此输出<code>undefined</code>而不是报错。</p><h2 id="_2-let和const的引入及暂时性死区-tdz" tabindex="-1">2. <code>let</code>和<code>const</code>的引入及暂时性死区 (TDZ) <a class="header-anchor" href="#_2-let和const的引入及暂时性死区-tdz" aria-label="Permalink to &quot;2. \`let\`和\`const\`的引入及暂时性死区 (TDZ)&quot;">​</a></h2><p>ES6引入了<code>let</code>和<code>const</code>关键字，它们的变量声明也会被提升，但在实际声明之前访问会抛出引用错误。这种现象被称为“暂时性死区”（Temporal Dead Zone, TDZ）。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 抛出 ReferenceError</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>在这里，由于<code>b</code>是用<code>let</code>声明的，在声明之前访问会导致引用错误。这与<code>var</code>不同，<code>var</code>允许在声明之前访问变量，但值为<code>undefined</code>。</p><h2 id="_3-变量环境" tabindex="-1">3. 变量环境 <a class="header-anchor" href="#_3-变量环境" aria-label="Permalink to &quot;3. 变量环境&quot;">​</a></h2><p>变量环境是一个抽象概念，表示当前执行上下文中的所有变量和函数声明。每个执行上下文都有一个与之关联的变量环境：</p><ul><li>全局执行上下文的变量环境是全局对象（如浏览器中的<code>window</code>或Node.js中的<code>global</code>）。</li><li>函数执行上下文的变量环境包含函数内部定义的变量和函数。</li></ul><h2 id="_4-词法环境" tabindex="-1">4. 词法环境 <a class="header-anchor" href="#_4-词法环境" aria-label="Permalink to &quot;4. 词法环境&quot;">​</a></h2><p>词法环境是JavaScript用于管理变量和函数声明的机制。它包含：</p><ul><li>当前作用域内所有变量和函数的绑定信息。</li><li>对外部环境的引用，形成作用域链。</li></ul><p>这种机制允许内部作用域访问外部作用域的变量，即使函数调用结束后，闭包仍然可以访问这些变量。</p><h2 id="_5-调用栈与执行上下文" tabindex="-1">5. 调用栈与执行上下文 <a class="header-anchor" href="#_5-调用栈与执行上下文" aria-label="Permalink to &quot;5. 调用栈与执行上下文&quot;">​</a></h2><p>调用栈是JavaScript管理函数调用的机制。每次调用函数时，会创建一个新的执行上下文并推入调用栈顶部。函数执行完毕后，其执行上下文会从调用栈中弹出。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;b&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &quot;a&quot; 和 &quot;b&quot;</span></span></code></pre></div><p>在这个例子中：</p><ol><li>调用<code>a</code>时，<code>a</code>的执行上下文被推入调用栈。</li><li><code>a</code>调用<code>b</code>时，<code>b</code>的执行上下文被推入调用栈。</li><li><code>b</code>执行完毕后，其执行上下文被移除，控制权返回给<code>a</code>。</li></ol><h2 id="_6-词法作用域与块级作用域" tabindex="-1">6. 词法作用域与块级作用域 <a class="header-anchor" href="#_6-词法作用域与块级作用域" aria-label="Permalink to &quot;6. 词法作用域与块级作用域&quot;">​</a></h2><p>词法作用域基于代码书写的位置决定变量的可见性。函数创建时会记录其外部环境的引用，从而形成作用域链。块级作用域由<code>let</code>和<code>const</code>引入，限制变量的作用范围。例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 块级作用域内的b</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 属于foo的作用域</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 块级作用域内的d</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 抛出 ReferenceError: d is not defined</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>在这段代码中：</p><ol><li><code>a</code>和<code>c</code>被提升到<code>foo</code>的作用域顶部。</li><li><code>b</code>和<code>d</code>被提升到各自的块级作用域，但在声明之前处于TDZ。</li><li>块级作用域内的<code>b</code>覆盖了外部作用域的<code>b</code>。</li><li><code>d</code>仅在块级作用域内可见，块外访问会抛出引用错误。</li></ol><h2 id="_7-原文来源掘金" tabindex="-1">7. 原文来源掘金 <a class="header-anchor" href="#_7-原文来源掘金" aria-label="Permalink to &quot;7. 原文来源掘金&quot;">​</a></h2><p><a href="https://juejin.cn/post/7442226311169523746?searchId=2025041922411232CB93C6911CB881EF2C" target="_blank" rel="noreferrer">点击跳转</a></p>`,29)),h(i)])}const F=a(p,[["render",k]]);export{y as __pageData,F as default};
