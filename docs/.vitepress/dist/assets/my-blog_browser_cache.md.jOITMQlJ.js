import{_ as i,B as t,c as l,o,ai as r,G as h}from"./chunks/framework.jrH_H5Hh.js";const m=JSON.parse('{"title":"浏览器缓存机制","description":"","frontmatter":{},"headers":[],"relativePath":"my-blog/browser/cache.md","filePath":"my-blog/browser/cache.md"}'),s={name:"my-blog/browser/cache.md"};function c(d,a,n,u,p,_){const e=t("GiscusComment");return o(),l("div",null,[a[0]||(a[0]=r(`<h1 id="浏览器缓存机制" tabindex="-1">浏览器缓存机制 <a class="header-anchor" href="#浏览器缓存机制" aria-label="Permalink to &quot;浏览器缓存机制&quot;">​</a></h1><p>浏览器缓存机制是提升网页性能的核心技术，通过本地存储资源减少网络请求。以下是其核心要点：</p><h2 id="_1-缓存类型与存储位置" tabindex="-1">1. 缓存类型与存储位置 <a class="header-anchor" href="#_1-缓存类型与存储位置" aria-label="Permalink to &quot;1. 缓存类型与存储位置&quot;">​</a></h2><h3 id="_1-1-内存缓存-memory-cache" tabindex="-1">1.1 内存缓存（Memory Cache） <a class="header-anchor" href="#_1-1-内存缓存-memory-cache" aria-label="Permalink to &quot;1.1 内存缓存（Memory Cache）&quot;">​</a></h3><ul><li>存储临时资源（如 CSS/JS），读取速度最快。</li><li>生命周期随浏览器标签页关闭而结束。</li></ul><h3 id="_1-2-磁盘缓存-disk-cache" tabindex="-1">1.2 磁盘缓存（Disk Cache） <a class="header-anchor" href="#_1-2-磁盘缓存-disk-cache" aria-label="Permalink to &quot;1.2 磁盘缓存（Disk Cache）&quot;">​</a></h3><ul><li>持久化存储大文件（如图片/视频）。</li><li>根据 HTTP 头策略决定缓存周期，容量可达数百 MB。</li></ul><h3 id="_1-3-service-worker-缓存" tabindex="-1">1.3 Service Worker 缓存 <a class="header-anchor" href="#_1-3-service-worker-缓存" aria-label="Permalink to &quot;1.3 Service Worker 缓存&quot;">​</a></h3><ul><li>可编程控制的持久化缓存。</li><li>支持离线访问，需 HTTPS 协议。</li></ul><h3 id="_1-4-push-cache-http-2-专属" tabindex="-1">1.4 Push Cache（HTTP/2 专属） <a class="header-anchor" href="#_1-4-push-cache-http-2-专属" aria-label="Permalink to &quot;1.4 Push Cache（HTTP/2 专属）&quot;">​</a></h3><ul><li>会话级临时缓存，有效期约 5 分钟。</li><li>优先级最低，适合预加载资源。</li></ul><h2 id="_2-缓存控制策略" tabindex="-1">2. 缓存控制策略 <a class="header-anchor" href="#_2-缓存控制策略" aria-label="Permalink to &quot;2. 缓存控制策略&quot;">​</a></h2><h3 id="_2-1-强缓存-无服务器交互" tabindex="-1">2.1 强缓存（无服务器交互） <a class="header-anchor" href="#_2-1-强缓存-无服务器交互" aria-label="Permalink to &quot;2.1 强缓存（无服务器交互）&quot;">​</a></h3><ul><li>通过 <code>Cache-Control</code>（优先级高）和 <code>Expires</code> 头控制。</li><li>常见指令： <ul><li><code>Cache-Control: max-age=31536000, public</code> // 缓存 1 年。</li><li><code>Cache-Control: no-store</code> // 禁止缓存。</li></ul></li></ul><h3 id="_2-2-协商缓存-需服务器验证" tabindex="-1">2.2 协商缓存（需服务器验证） <a class="header-anchor" href="#_2-2-协商缓存-需服务器验证" aria-label="Permalink to &quot;2.2 协商缓存（需服务器验证）&quot;">​</a></h3><ul><li>校验机制： <ul><li><code>Last-Modified</code> + <code>If-Modified-Since</code>（时间戳比对）。</li><li><code>ETag</code> + <code>If-None-Match</code>（内容哈希值比对）。</li></ul></li><li>返回 304 状态码复用缓存。</li></ul><h2 id="_3-缓存工作流程" tabindex="-1">3. 缓存工作流程 <a class="header-anchor" href="#_3-缓存工作流程" aria-label="Permalink to &quot;3. 缓存工作流程&quot;">​</a></h2><h3 id="_3-1-首次请求" tabindex="-1">3.1 首次请求 <a class="header-anchor" href="#_3-1-首次请求" aria-label="Permalink to &quot;3.1 首次请求&quot;">​</a></h3><p>首次请求时，服务器返回资源及缓存头（如 <code>Cache-Control</code> 和 <code>ETag</code>）。</p><h3 id="_3-2-再次请求" tabindex="-1">3.2 再次请求 <a class="header-anchor" href="#_3-2-再次请求" aria-label="Permalink to &quot;3.2 再次请求&quot;">​</a></h3><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">graph LR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A[检查内存缓存] --&gt;|命中| B[直接使用]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A --&gt;|未命中| C[检查磁盘缓存]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">C --&gt;|过期| D[发送条件请求]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D --&gt;|304| E[复用缓存]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">D --&gt;|200| F[更新缓存]</span></span></code></pre></div><h2 id="_4-特殊机制" tabindex="-1">4. 特殊机制 <a class="header-anchor" href="#_4-特殊机制" aria-label="Permalink to &quot;4. 特殊机制&quot;">​</a></h2><h3 id="_4-1-启发式缓存" tabindex="-1">4.1 启发式缓存 <a class="header-anchor" href="#_4-1-启发式缓存" aria-label="Permalink to &quot;4.1 启发式缓存&quot;">​</a></h3><p>当未显式设置 <code>Cache-Control</code> 时，浏览器按公式计算缓存时间：<br> $$缓存时间 = (Date - Last-Modified) \\times 0.1$$<br> 例如资源最后修改于 30 天前，则默认缓存 3 天。</p><h3 id="_4-2-用户行为影响" tabindex="-1">4.2 用户行为影响 <a class="header-anchor" href="#_4-2-用户行为影响" aria-label="Permalink to &quot;4.2 用户行为影响&quot;">​</a></h3><table tabindex="0"><thead><tr><th>操作方式</th><th>缓存处理</th></tr></thead><tbody><tr><td>地址栏回车</td><td>遵守缓存头</td></tr><tr><td>Ctrl+F5 强制刷新</td><td>跳过所有缓存</td></tr><tr><td>清除缓存并硬性重新加载</td><td>先删除缓存再请求新资源</td></tr></tbody></table><h2 id="_5-最佳实践" tabindex="-1">5. 最佳实践 <a class="header-anchor" href="#_5-最佳实践" aria-label="Permalink to &quot;5. 最佳实践&quot;">​</a></h2><ol><li>静态资源设置长期缓存（如 <code>max-age=31536000</code>）。</li><li>使用内容哈希命名文件（如 <code>app.3a87b12.js</code>）。</li><li>动态资源采用 <code>no-cache</code> + <code>ETag</code> 验证。</li></ol><p>通过合理配置，缓存可使页面加载速度提升 50% 以上。开发者可通过 Chrome DevTools 的 Network 面板查看具体资源的缓存状态和策略。</p>`,29)),h(e)])}const k=i(s,[["render",c]]);export{m as __pageData,k as default};
