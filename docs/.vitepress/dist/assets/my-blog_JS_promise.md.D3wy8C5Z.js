import{_ as i,B as l,c as r,o as s,ai as a,G as d}from"./chunks/framework.jrH_H5Hh.js";const g=JSON.parse('{"title":"Promise","description":"","frontmatter":{},"headers":[],"relativePath":"my-blog/JS/promise.md","filePath":"my-blog/JS/promise.md"}'),t={name:"my-blog/JS/promise.md"};function c(m,e,n,P,h,p){const o=l("GiscusComment");return s(),r("div",null,[e[0]||(e[0]=a('<h1 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h1><h2 id="_1-对-promise-的理解" tabindex="-1">1. 对 Promise 的理解 <a class="header-anchor" href="#_1-对-promise-的理解" aria-label="Permalink to &quot;1. 对 Promise 的理解&quot;">​</a></h2><p>Promise 是一种用于解决异步编程问题的方案，它可以将异步操作以同步操作的流程表达出来，从而避免回调地狱。</p><h3 id="promise-的状态" tabindex="-1">Promise 的状态 <a class="header-anchor" href="#promise-的状态" aria-label="Permalink to &quot;Promise 的状态&quot;">​</a></h3><p>Promise 实例有三种状态：</p><ul><li><strong>Pending</strong>（初始状态）</li><li><strong>Fulfilled</strong>（成功状态）</li><li><strong>Rejected</strong>（失败状态）</li></ul><h3 id="状态转换过程" tabindex="-1">状态转换过程 <a class="header-anchor" href="#状态转换过程" aria-label="Permalink to &quot;状态转换过程&quot;">​</a></h3><p>Promise 实例的状态转换过程如下：</p><ul><li><code>Pending</code> → <code>Fulfilled</code>：称为 <strong>Resolved</strong>（已完成）</li><li><code>Pending</code> → <code>Rejected</code>：称为 <strong>Rejected</strong>（已拒绝）</li></ul><p><strong>注意</strong>：一旦状态从 <code>Pending</code> 转变为其他状态，就无法再更改，状态转换是不可逆的。</p><h3 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数&quot;">​</a></h3><p>Promise 构造函数接收一个带有 <code>resolve</code> 和 <code>reject</code> 参数的回调函数：</p><ul><li><code>resolve</code>：将 Promise 状态从 <code>Pending</code> 变为 <code>Fulfilled</code>，在异步操作成功时调用，并将异步结果作为参数传递出去。</li><li><code>reject</code>：将 Promise 状态从 <code>Pending</code> 变为 <code>Rejected</code>，在异步操作失败时调用，并将错误信息作为参数传递出去。</li></ul><h3 id="promise-的缺点" tabindex="-1">Promise 的缺点 <a class="header-anchor" href="#promise-的缺点" aria-label="Permalink to &quot;Promise 的缺点&quot;">​</a></h3><ol><li>无法取消 Promise，一旦创建就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise 内部抛出的错误不会反映到外部。</li><li>当处于 <code>Pending</code> 状态时，无法得知当前进展到哪一个阶段（刚开始还是即将完成）。</li></ol><hr><h2 id="_2-promise-方法" tabindex="-1">2. Promise 方法 <a class="header-anchor" href="#_2-promise-方法" aria-label="Permalink to &quot;2. Promise 方法&quot;">​</a></h2><ul><li><strong><code>promise.then()</code></strong>：处理 <code>resolve</code> 成功的情况。</li><li><strong><code>promise.catch()</code></strong>：处理 <code>reject</code> 失败的情况。</li><li><strong><code>promise.all()</code></strong>：用于并行处理多个 Promise 实例，将多个 Promise 实例的数组包装成一个新的 Promise 实例。返回的实例是普通的 Promise： <ul><li>如果所有子 Promise 都成功，返回值是所有结果组成的数组。</li><li>如果有一个子 Promise 失败，则整个 Promise 失败。</li></ul></li><li><strong><code>promise.race()</code></strong>：与 <code>promise.all()</code> 类似，但只要任意一个子 Promise 完成，就会立即返回结果。</li><li><strong><code>promise.allSettled()</code></strong>：返回一个新的 Promise，当所有给定的 Promise 都已 <code>Fulfilled</code> 或 <code>Rejected</code> 后完成。返回值是一个对象数组，每个对象表示对应 Promise 的结果。</li></ul><hr><h2 id="_3-promise-all-和-promise-allsettled-的区别" tabindex="-1">3. <code>promise.all</code> 和 <code>promise.allSettled</code> 的区别 <a class="header-anchor" href="#_3-promise-all-和-promise-allsettled-的区别" aria-label="Permalink to &quot;3. `promise.all` 和 `promise.allSettled` 的区别&quot;">​</a></h2><h3 id="promise-all" tabindex="-1"><code>Promise.all</code> <a class="header-anchor" href="#promise-all" aria-label="Permalink to &quot;`Promise.all`&quot;">​</a></h3><ul><li>只有当所有 Promise 实例都 <code>resolve</code> 后，才会返回一个由所有 Promise 返回值组成的数组。</li><li>如果有一个 Promise 实例 <code>reject</code>，则整个 Promise 会立即被拒绝，并返回拒绝原因。</li><li>类比：团队中所有成员成功才算成功，如果有一个人失败就算失败。</li></ul><h3 id="promise-allsettled" tabindex="-1"><code>Promise.allSettled</code> <a class="header-anchor" href="#promise-allsettled" aria-label="Permalink to &quot;`Promise.allSettled`&quot;">​</a></h3><ul><li>等所有 Promise 执行完毕后（无论成功或失败），返回一个包含每个 Promise 状态信息的数组。</li><li>类比：团队中每个人的结果都会被记录，无论成功还是失败。</li></ul>',24)),d(o)])}const _=i(t,[["render",c]]);export{g as __pageData,_ as default};
