import{_ as o,B as r,c as i,o as n,ai as s,G as e}from"./chunks/framework.jrH_H5Hh.js";const _=JSON.parse('{"title":"HTTPS 与 HTTP 的区别与工作原理","description":"","frontmatter":{},"headers":[],"relativePath":"my-blog/computer-network/https.md","filePath":"my-blog/computer-network/https.md"}'),a={name:"my-blog/computer-network/https.md"};function T(p,t,h,g,c,P){const l=r("GiscusComment");return n(),i("div",null,[t[0]||(t[0]=s('<h1 id="https-与-http-的区别与工作原理" tabindex="-1">HTTPS 与 HTTP 的区别与工作原理 <a class="header-anchor" href="#https-与-http-的区别与工作原理" aria-label="Permalink to &quot;HTTPS 与 HTTP 的区别与工作原理&quot;">​</a></h1><h2 id="_1-https-和-http-有哪些区别" tabindex="-1">1. HTTPS 和 HTTP 有哪些区别 <a class="header-anchor" href="#_1-https-和-http-有哪些区别" aria-label="Permalink to &quot;1. HTTPS 和 HTTP 有哪些区别&quot;">​</a></h2><p>HTTPS 和 HTTP 的主要区别在于安全性和信息加密。HTTP 的信息是明文传输的，因此存在以下三种安全风险：</p><ul><li><strong>窃听风险</strong>：信息可能被第三方窃取。</li><li><strong>篡改风险</strong>：信息可能在传输过程中被篡改。</li><li><strong>冒充风险</strong>：可能遭遇伪装成合法服务器的攻击。</li></ul><p>HTTPS 通过在 HTTP 和 TCP 层之间加入 <strong>TLS 层</strong>，很好地解决了这些问题：</p><ul><li>使用 <strong>混合加密算法</strong> 实现信息加密，解决窃听风险。</li><li>通过 <strong>摘要算法</strong> 为信息生成唯一的哈希值，用于校验信息，解决篡改风险。</li><li>将服务器公钥存放在 <strong>数字证书</strong> 中，解决冒充风险。</li></ul><p>此外，HTTPS 的默认端口号是 <strong>443</strong>，而 HTTP 的默认端口号是 <strong>80</strong>。由于 HTTPS 增加了 TLS 层，客户端和服务端在使用 HTTPS 协议连接时，除了进行 TCP 的三次握手，还需要进行 <strong>SSL/TLS 的握手过程</strong>。</p><hr><h2 id="_2-https-的工作原理-建立连接的过程" tabindex="-1">2. HTTPS 的工作原理（建立连接的过程） <a class="header-anchor" href="#_2-https-的工作原理-建立连接的过程" aria-label="Permalink to &quot;2. HTTPS 的工作原理（建立连接的过程）&quot;">​</a></h2><p>HTTPS 建立连接需要经过 <strong>TCP 三次握手</strong> 和 <strong>TLS 四次握手</strong>。以下是 TLS 握手的具体过程：</p><ol><li><strong>客户端发起请求</strong><br> 客户端向服务器发起加密通信请求，包含以下信息：</li></ol><ul><li>支持的 TLS 版本。</li><li>客户端生成的随机数。</li><li>客户端支持的密码套件列表。</li></ul><ol start="2"><li><strong>服务器响应客户端</strong><br> 服务器收到请求后，返回以下信息：</li></ol><ul><li>确认的 TLS 协议版本（如果客户端不支持，则关闭加密通信）。</li><li>确认的密码套件。</li><li>服务器生成的随机数。</li><li>服务器的数字证书。</li></ul><ol start="3"><li><strong>客户端验证并发送加密信息</strong><br> 客户端验证数字证书的真实性。如果验证通过，客户端从证书中提取公钥，并发送以下加密信息：</li></ol><ul><li>一个随机数。</li><li>加密通信算法的改变通知（表示后续通信将使用会话密钥加密）。</li><li>客户端握手结束通知。</li></ul><ol start="4"><li><strong>服务器解密并完成握手</strong><br> 服务器使用私钥解密客户端发送的信息，获取随机数。此时，客户端和服务器通过以下步骤生成会话密钥：</li></ol><ul><li>利用三个随机数（客户端随机数、服务器随机数、客户端发送的随机数）。</li><li>协商出的加密算法。</li></ul><p>最后，服务器向客户端发送以下信息：</p><ul><li>加密通信算法的改变通知。</li><li>服务器握手结束通知。</li></ul><p>完成以上步骤后，TLS 握手阶段结束，客户端和服务器进入 <strong>会话密钥加密通信</strong> 阶段。</p><hr><h2 id="_3-小林coding" tabindex="-1">3. 小林coding <a class="header-anchor" href="#_3-小林coding" aria-label="Permalink to &quot;3. 小林coding&quot;">​</a></h2><p><a href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https" target="_blank" rel="noreferrer">点击跳转</a></p>',24)),e(l)])}const d=o(a,[["render",T]]);export{_ as __pageData,d as default};
