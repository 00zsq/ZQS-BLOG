import{_ as s,B as l,c as n,o as t,ai as e,G as o}from"./chunks/framework.jrH_H5Hh.js";const D=JSON.parse('{"title":"虚拟 DOM","description":"","frontmatter":{},"headers":[],"relativePath":"my-blog/Vue/v-DOM.md","filePath":"my-blog/Vue/v-DOM.md"}'),r={name:"my-blog/Vue/v-DOM.md"};function h(d,a,p,k,c,g){const i=l("GiscusComment");return t(),n("div",null,[a[0]||(a[0]=e(`<h1 id="虚拟-dom" tabindex="-1">虚拟 DOM <a class="header-anchor" href="#虚拟-dom" aria-label="Permalink to &quot;虚拟 DOM&quot;">​</a></h1><h2 id="_1-笔记" tabindex="-1">1. 笔记 <a class="header-anchor" href="#_1-笔记" aria-label="Permalink to &quot;1. 笔记&quot;">​</a></h2><ul><li><strong>浏览器原理</strong>：26 虚拟 DOM——虚拟 DOM 和实际的 DOM 有何不同。</li><li><strong>Vue.js 设计与实现（霍春阳）</strong>：1.3 虚拟 DOM 的性能到底如何。</li></ul><h2 id="_2-vue-中的虚拟-dom-vdom-是什么" tabindex="-1">2. Vue 中的虚拟 DOM（VDOM）是什么？ <a class="header-anchor" href="#_2-vue-中的虚拟-dom-vdom-是什么" aria-label="Permalink to &quot;2. Vue 中的虚拟 DOM（VDOM）是什么？&quot;">​</a></h2><p>虚拟 DOM（Virtual DOM）是 Vue.js 的核心机制之一，它是一个轻量级的 JavaScript 对象，用于描述真实 DOM 的结构和属性。</p><h3 id="核心原理" tabindex="-1">核心原理 <a class="header-anchor" href="#核心原理" aria-label="Permalink to &quot;核心原理&quot;">​</a></h3><ol><li><strong>抽象表示</strong>：用 JavaScript 对象模拟真实 DOM 的树形结构（称为 VNode）。</li><li><strong>Diff 算法</strong>：通过比较新旧虚拟 DOM 树的差异，计算出最小化的 DOM 操作。</li><li><strong>批量更新</strong>：将差异应用到真实 DOM，减少直接操作真实 DOM 的次数。</li></ol><h4 id="示例代码" tabindex="-1">示例代码 <a class="header-anchor" href="#示例代码" aria-label="Permalink to &quot;示例代码&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 虚拟 DOM 的简单表示</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> vnode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  props: { id: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  children: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;h1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, children: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello Vue!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="_3-虚拟-dom-的优势" tabindex="-1">3. 虚拟 DOM 的优势 <a class="header-anchor" href="#_3-虚拟-dom-的优势" aria-label="Permalink to &quot;3. 虚拟 DOM 的优势&quot;">​</a></h2><ol><li><strong>性能优化</strong><ul><li>减少直接操作真实 DOM 的开销（如重绘和回流）。</li><li>在复杂应用中（如高频数据更新、大型列表），通过 Diff 算法批量更新 DOM 更高效。</li></ul></li><li><strong>跨平台能力</strong><ul><li>虚拟 DOM 不依赖浏览器，可用于服务端渲染（SSR）、移动端（如 Weex）等。</li></ul></li><li><strong>开发体验</strong><ul><li>开发者只需关注数据变化，无需手动操作 DOM。</li></ul></li></ol><h2 id="_4-虚拟-dom-一定会提升性能吗" tabindex="-1">4. 虚拟 DOM 一定会提升性能吗？ <a class="header-anchor" href="#_4-虚拟-dom-一定会提升性能吗" aria-label="Permalink to &quot;4. 虚拟 DOM 一定会提升性能吗？&quot;">​</a></h2><p>不一定，需分场景讨论：</p><h3 id="性能提升的场景" tabindex="-1">性能提升的场景 <a class="header-anchor" href="#性能提升的场景" aria-label="Permalink to &quot;性能提升的场景&quot;">​</a></h3><ul><li>复杂 UI 或频繁更新的应用（如动态表单、实时图表）。</li><li>跨平台渲染时（如同一代码适配 Web 和移动端）。</li></ul><h3 id="可能不提升性能的场景" tabindex="-1">可能不提升性能的场景 <a class="header-anchor" href="#可能不提升性能的场景" aria-label="Permalink to &quot;可能不提升性能的场景&quot;">​</a></h3><ul><li><strong>简单静态页面</strong>：直接操作真实 DOM 可能更快（虚拟 DOM 的 Diff 计算反而增加开销）。</li><li><strong>极致性能需求</strong>：手动优化 DOM 操作（如游戏、动画）可能优于虚拟 DOM 的默认行为。</li></ul><h2 id="_5-虚拟-dom-的局限性" tabindex="-1">5. 虚拟 DOM 的局限性 <a class="header-anchor" href="#_5-虚拟-dom-的局限性" aria-label="Permalink to &quot;5. 虚拟 DOM 的局限性&quot;">​</a></h2><ol><li><strong>初始渲染开销</strong>：首次渲染需额外生成虚拟 DOM 树。</li><li><strong>内存占用</strong>：维护虚拟 DOM 树需要额外的内存。</li><li><strong>过度依赖 Diff 算法</strong>：若 Diff 逻辑复杂（如深层嵌套组件），可能成为性能瓶颈。</li></ol><h2 id="_6-如何优化虚拟-dom-的性能" tabindex="-1">6. 如何优化虚拟 DOM 的性能？ <a class="header-anchor" href="#_6-如何优化虚拟-dom-的性能" aria-label="Permalink to &quot;6. 如何优化虚拟 DOM 的性能？&quot;">​</a></h2><ol><li><strong>合理使用 key</strong>：列表渲染时提供唯一 key，帮助 Diff 算法高效识别节点。</li><li><strong>避免不必要的渲染</strong>：通过 <code>v-once</code> 或 <code>shouldComponentUpdate</code> 减少重复计算。</li><li><strong>组件拆分</strong>：将大型组件拆分为小块，缩小 Diff 范围。</li></ol>`,21)),o(i)])}const E=s(r,[["render",h]]);export{D as __pageData,E as default};
