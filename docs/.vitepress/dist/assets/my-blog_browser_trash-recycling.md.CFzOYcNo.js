import{_ as t,B as o,c as a,o as i,ai as n,G as e}from"./chunks/framework.jrH_H5Hh.js";const b=JSON.parse('{"title":"JS垃圾回收机制","description":"","frontmatter":{},"headers":[],"relativePath":"my-blog/browser/trash-recycling.md","filePath":"my-blog/browser/trash-recycling.md"}'),s={name:"my-blog/browser/trash-recycling.md"};function g(c,r,h,u,_,d){const l=o("GiscusComment");return i(),a("div",null,[r[0]||(r[0]=n('<h1 id="js垃圾回收机制" tabindex="-1">JS垃圾回收机制 <a class="header-anchor" href="#js垃圾回收机制" aria-label="Permalink to &quot;JS垃圾回收机制&quot;">​</a></h1><ul><li>垃圾回收机制(Garbage Collection)简称GC</li><li>JS中<strong>内存的分配和回收</strong>是<strong>自动完成</strong>的，内存在不使用的时候会被<strong>垃圾回收器</strong>自动回收</li></ul><h2 id="_1-内存的生命周期" tabindex="-1">1. 内存的生命周期 <a class="header-anchor" href="#_1-内存的生命周期" aria-label="Permalink to &quot;1. 内存的生命周期&quot;">​</a></h2><p>JS环境中分配的内存，一般有如下生命周期</p><ul><li><strong>内存分配</strong>：声明变量、函数、对象的时候，系统会自动为他们分配内存</li><li><strong>内存使用</strong>：即读写内存，也就是使用变量、函数等</li><li><strong>内存回收</strong>：使用完毕，由<strong>垃圾回收器</strong>自动回收不再使用的内存</li><li><strong>全局变量</strong>一般不会回收（关闭页面时回收）</li><li>一般情况下<strong>局部变量</strong>的值<strong>不用会被自动回收</strong></li><li>内存泄漏：程序中<strong>分配的内存</strong>由于某些原因程序<strong>未释放或无法释放</strong>叫内存泄露</li></ul><h2 id="_2-算法说明" tabindex="-1">2. 算法说明 <a class="header-anchor" href="#_2-算法说明" aria-label="Permalink to &quot;2. 算法说明&quot;">​</a></h2><ul><li>栈：由<strong>操作系统自动分配释放</strong>函数的参数值、局部变量等，基本数据类型放到栈里面</li><li>堆：一般由程序员分配释放，若程序员不释放，由<strong>垃圾回收机制</strong>回收，<strong>复杂数据类型</strong>放到堆里面</li></ul><h2 id="_3-引用计数法" tabindex="-1">3. 引用计数法 <a class="header-anchor" href="#_3-引用计数法" aria-label="Permalink to &quot;3. 引用计数法&quot;">​</a></h2><ul><li>IE采用的算法，定义”内存不再使用“，就是看一个对象是否有指向它的引用，没有引用就回收 <ul><li>1、跟踪记录<strong>被引用的次数</strong></li><li>2、如果被引用次数为1就记录为1，多次引用就++</li><li>3、如果减少一个引用就--</li><li>4、如果引用次数为0就释放内存</li></ul></li><li>缺点：嵌套引用（循环引用） <ul><li>如果两个对象互相引用，尽管已经不会使用，垃圾回收器也不会进行回收，导致内存泄漏</li><li>因为他们的引用次数永远不会是0</li></ul></li></ul><h2 id="_4-标记清除法" tabindex="-1">4. 标记清除法 <a class="header-anchor" href="#_4-标记清除法" aria-label="Permalink to &quot;4. 标记清除法&quot;">​</a></h2><ul><li>标记清除法将”不再使用的对象“定义为”<strong>无法达到的对象</strong>“</li><li>就是从<strong>根部（在JS中就是全局对象）<strong>出发定时扫描内存中的对象。凡是</strong>能从根部到达的对象都是还需要使用的</strong></li><li>那些无法由根部出发触及到的对象被<strong>标记为不再使用，稍后进行回收</strong></li></ul><h2 id="_5-深入" tabindex="-1">5. 深入 <a class="header-anchor" href="#_5-深入" aria-label="Permalink to &quot;5. 深入&quot;">​</a></h2><ul><li>需要涉及到调用栈、堆空间以及主副垃圾回收器……所以直接跳转</li><li>浏览器原理文档 13.13垃圾回收：垃圾数据是如何自动回收的？</li><li><a href="https://juejin.cn/post/7138038723958030350?searchId=2025041715562648D304953AB3A0EAB0FF" target="_blank" rel="noreferrer">点击跳转</a></li></ul>',13)),e(l)])}const p=t(s,[["render",g]]);export{b as __pageData,p as default};
